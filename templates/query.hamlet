<h1>
  Query

<br />
<br />

Fluid's <span style="font-weight: bold">query language</span> is a simple and complete <span style="font-weight: bold">programming language</span>.
The query language, partially inspired by LISP, has roots in functional programming.

<br />
<br />

<h2> Request Body
<br />

Interaction with a Fluid API is through the <code>"query"</code> portion of the JSON request body.
Code in the query language should be placed here.

<br />
<br />

<table .table .table-striped .table-condensed .table-bordered>
  <tbody>
    <tr>
      <td>
        <code style="background-color: transparent">
          {<br/>
          &nbsp;&nbsp;"fluid": {"major": 0, "minor": 0},<br/>
          &nbsp;&nbsp;"version": {"major": 0, "minor": 0},<br/>
          &nbsp;&nbsp;"meta": &lt;META_HERE&gt;,<br/>
          &nbsp;&nbsp;"query": <span style="background-color: #ff0">&lt;QUERY_HERE&gt;</span><br/>
          }
<br />
<br />

<h2> JSON
<br />

For better or worse, the query language is in JSON.
<br />
<br />
There are few reasons to shape up JSON from a transport format into a programming language -- opposed to creating a query language with a different syntax.
<br />
<br />
1. Many existing tools for dealing with Web APIs are designed with JSON in mind.
And from a purely practical perspective, not all programming languages currently have a Fluid implementation.
But all languages can already interact with a JSON API.
This possibility forces an additional constraint for clear readability.
<br />
<br />
2. Users of generated clients don't care about the transport format.
And they shouldn't care (unless something goes wrong).
There's no need to reinvent the wheel of another transport format.
Moving away from JSON will only upset those with existing tools and non-generated clients.
JSON is the widely accepted norm.
<br />
<br />
3. Because all languages can interact with a JSON API,
each one has a unique and existing story for serializing and deserializing JSON.
By using JSON, an entire and crucial class of the work is avoided.
Mostly what's left is integrations with a server runtime and a client AST generator.
Neither implementations are triviality regardless of language.
<br />
<br />
These are valid enough reasons to commit that the transport format is a first-class priority.
JSON, the transport format and now programming language, adequately satisfies them.
<br />
<br />

<h2> Sandboxed Runtimes
<br />

At the price of flexbility, running client code on the server risks vulernabilities.
Such code should be sandboxed.
And it is under full control of the server with a few hooks.
Each request's query is always sandboxed separately.

<h3> Authentication and Authorization
<br />

Because who sends the request is key detail for managing a sandbox,
request headers and the <code>"meta"</code> inside the request body are available when sandboxing.
<br />
<br />
This is the most flexible approach.
The server already decides how to authenticate and authorize at runtime.
How that happens is mystery to the sandboxed runtime.
It's really no business of any Fluid code to know how.
Rules can be loose or strict and static or dynamic as desired.

<h2> Types

As a part of being small, the query language has its own idioms which work along with the nature of JSON.

<h4> null

<h3> Collections

<h4> Option

Because every JSON value has the potential to be <code>null</code>, it's overloaded to represent the <code>None</code> of <code>Option</code> values.
This follows a common pattern of JSON translations with static languages.
From It simples the underlying JSON value in a <code>Some</code> just to be itself.
Nonsensical and a rarity, nested <code>Option</code> types are discouraged.

<h4> Tuple

<table .table .table-striped .table-condensed .table-bordered>
  <tbody>
    <tr>
      <td>
        <code style="background-color: transparent">
          ["tuple", &lt;x0&gt;, &lt;x1&gt;, &lt;x2&gt;, ...]

<h4> List


<h2> Built-in functions

<h3> if

<h3> do

<h3> def

<h3> fn

<h3> match
